Database System Concepts, 7th Ed.
©Silberschatz, Korth and Sudarshan
See www.db-book.com for conditions on re-use
Chapter 7: Normalization
©Silberschatz, Korth and Sudarshan7.2Database System Concepts - 7th Edition
Outline
 Features of Good Relational Model Design
 Functional Dependencies
 Decomposition Using Functional Dependencies
 Normal Forms
 Functional Dependency Theory
 Algorithms for Decomposition using Functional Dependencies
 Decomposition Using Multivalued Dependencies
 More Normal Form
 Atomic Domains and First Normal Form
 Database-Design Process
 Modeling Temporal Data
©Silberschatz, Korth and Sudarshan7.3Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.4Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.5Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.6Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.7Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.8Database System Concepts - 7th Edition
Features of Good Relational Model Designs
 Suppose we combine instructor and department into in_dep, which
represents the natural join on the relations instructor and department
 There is repetition of information
 Need to use null values (if we add a new department with no instructors)
 Anomalies
 Update
 Insertion
 Deletion
©Silberschatz, Korth and Sudarshan7.9Database System Concepts - 7th Edition
A Combined Schema Without Repetition
 Consider combining relations
 sec_class(sec_id, building, room_number) and
 section(course_id, sec_id, semester, year)
into one relation
 section(course_id, sec_id, semester, year, building,
room_number)
 No repetition in this case
Not all combined schemas result in repetition
of information
©Silberschatz, Korth and Sudarshan7.10Database System Concepts - 7th Edition
Decomposition
 The only way to avoid the repetition-of-information problem in the in_dep
schema is to decompose it into two schemas – instructor and
department schemas.
 Not all decompositions are good. Suppose we decompose
employee(ID, name, street, city, salary)
into
employee1 (ID, name)
employee2 (name, street, city, salary)
The problem arises when we have two employees with the same name
 The next slide shows how we lose information -- we cannot reconstruct
the original employee relation -- and so, this is a lossy decomposition.
©Silberschatz, Korth and Sudarshan7.11Database System Concepts - 7th Edition
A Lossy Decomposition

©Silberschatz, Korth and Sudarshan7.12Database System Concepts - 7th Edition
Lossless Decomposition
 Let R be a relation schema and let R1 and R2 form a
decomposition of R . That is R = R1 U R2
 We say that the decomposition is a lossless
decomposition if there is no loss of information by
replacing R with the two relation schemas R1 U R2
 Formally,
∏ R1 (r) ∏ R2 (r) = r
 And, conversely a decomposition is lossy if
r ⊂ ∏ R1 (r) ∏ R2 (r)
©Silberschatz, Korth and Sudarshan7.13Database System Concepts - 7th Edition
Example of Lossless Decomposition
 Decomposition of R = (A, B, C)
R1 = (A, B) R2 = (B, C)

©Silberschatz, Korth and Sudarshan7.14Database System Concepts - 7th Edition
Normalization Theory
 Decide whether a particular relation R is in "good" form.
 In the case that a relation R is not in "good" form,
decompose it into set of relations {R1, R2, ..., Rn} such
that
 Each relation is in good form
 The decomposition is a lossless decomposition
 Our theory is based on:
 Functional dependencies
 Multivalued dependencies
©Silberschatz, Korth and Sudarshan7.15Database System Concepts - 7th Edition
Functional Dependencies
 There are usually a variety of constraints (rules) on the
data in the real world.
 For example, some of the constraints that are expected to
hold in a university database are:
 Students and instructors are uniquely identified by their
ID.
 Each student and instructor has only one name.
 Each instructor and student is (primarily) associated
with only one department.
 Each department has only one value for its budget, and
only one associated building.
©Silberschatz, Korth and Sudarshan7.16Database System Concepts - 7th Edition
Functional Dependencies (Cont.)
 An instance of a relation that satisfies all such real-world
constraints is called a legal instance of the relation;
 A legal instance of a database is one where all the relation
instances are legal instances
 Constraints on the set of legal relations require that the
value for a certain set of attributes determines uniquely the
value for another set of attributes.
 α → β (α determines β ), where α and β indicates set of
attributes
 A functional dependency is a generalization of the notion of
a key.
©Silberschatz, Korth and Sudarshan7.17Database System Concepts - 7th Edition
Functional Dependencies Definition
 Let R be a relation schema
α ⊆ R and β ⊆ R
 The functional dependency
α → β
holds on R if and only if for any legal relations r(R), whenever any two
tuples t1 and t2 of r agree on the attributes α, they also agree on the
attributes β. That is,
t1[α] = t2 [α] ⇒ t1[β ] = t2 [β ]
 Example: Consider r(A,B ) with the following instance of r.
 On this instance, B → A hold; A → B does NOT hold.
1 4
1 5
3 7
©Silberschatz, Korth and Sudarshan7.18Database System Concepts - 7th Edition
Closure of a Set of Functional Dependencies
 Given a set F of functional dependencies, there are certain
other functional dependencies that are logically implied by
F.
 If A → B and B → C, then we can infer that A → C,
etc.
 The set of all functional dependencies logically implied by
F is the closure of F.
 We denote the closure of F by F+.
©Silberschatz, Korth and Sudarshan7.19Database System Concepts - 7th Edition
Keys and Functional Dependencies
 K is a superkey for relation schema R if and only if K → R
 K is a candidate key for R if and only if
 K → R, and
 for no α ⊂ K, α → R
 Functional dependencies allow us to express constraints that cannot
be expressed using superkeys. Consider the schema:
in_dep (ID, name, salary, dept_name, building, budget ).
We expect these functional dependencies to hold:
dept_name→ building, budget
ID, dept_name  name, salary, building, budget (superkey)
ID  name, salary, dept_name, building, budget (candidate key)
but would not expect the following to hold:
dept_name → salary
©Silberschatz, Korth and Sudarshan7.20Database System Concepts - 7th Edition
Use of Functional Dependencies
 We use functional dependencies to:
 To test relations to see if they are legal under a given set of
functional dependencies.
 If a relation r is legal under a set F of functional dependencies,
we say that r satisfies F.
 To specify constraints on the set of legal relations
We say that F holds on R if all legal relations on R satisfy the
set of functional dependencies F.
 Note: A specific instance of a relation schema may satisfy a functional
dependency even if the functional dependency does not hold on all
legal instances.
 For example, a specific instance of instructor may, by chance,
satisfy
name → ID.
©Silberschatz, Korth and Sudarshan7.21Database System Concepts - 7th Edition
Trivial Functional Dependencies
Some functional dependencies are
trivial, if they satisfy all relations.
Example:
 ID, name → ID
 name → name
In general, α → β is trivial if β ⊆ α
©Silberschatz, Korth and Sudarshan7.22Database System Concepts - 7th Edition
Lossless Decomposition
 We can use functional dependencies to show when certain
decompositions are lossless.
 For the case of R = (R1, R2), we require that for all possible relations r
on schema R
r = ∏R1 (r ) ∏R2 (r )
 A decomposition of R into R1 and R2 is lossless decomposition if at
least one of the following dependencies is in F+:
 R1 ∩ R2 → R1
 R1 ∩ R2 → R2
 The above functional dependencies are a sufficient condition for
lossless join decomposition;
©Silberschatz, Korth and Sudarshan7.23Database System Concepts - 7th Edition
Example
 R = (A, B, C)
F = {A → B, B → C)
 R1 = (A, B), R2 = (B, C)
 Lossless decomposition:
R1 ∩ R2 = {B} and B → BC
 R1 = (A, B), R2 = (A, C)
 Lossless decomposition:
R1 ∩ R2 = {A} and A → AB
 Note:
 B → BC
is a shorthand notation for
 B → {B, C}
©Silberschatz, Korth and Sudarshan7.24Database System Concepts - 7th Edition
Dependency Preservation
 Testing functional dependency constraints each time the
database is updated can be costly
 It is useful to design the database in a way that constraints
can be tested efficiently.
 If testing a functional dependency can be done by
considering just one relation, then the cost of testing this
constraint is low
 When decomposing a relation it is possible that it is no
longer possible to do the testing without having to perform
a Cartesian Product.
 A decomposition that makes it computationally hard to
enforce functional dependency is said to be NOT
dependency preserving.
©Silberschatz, Korth and Sudarshan7.25Database System Concepts - 7th Edition
Dependency Preservation Example
 Consider a schema: dept_advisor(s_ID, i_ID, department_name)
 With function dependencies:
i_ID → dept_name
s_ID, dept_name → i_ID
 In the above design we are forced to repeat the department name once for
each time an instructor participates in a dept_advisor relationship.
 To fix this, we need to decompose dept_advisor into (s_ID, i_ID) & (i_ID,
dept_name)
 Any decomposition will not include all the attributes in
s_ID, dept_name → i_ID
 Thus, the decomposition NOT be dependency
preserving

©Silberschatz, Korth and Sudarshan7.26Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.27Database System Concepts - 7th Edition
Normal Forms
©Silberschatz, Korth and Sudarshan7.28Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.29Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.30Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.31Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.32Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.33Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.34Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.35Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.36Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.37Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.38Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.39Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.40Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.41Database System Concepts - 7th Edition

©Silberschatz, Korth and Sudarshan7.42Database System Concepts - 7th Edition
Boyce-Codd Normal Form
 A relation schema R is in BCNF with respect to a set F of
functional dependencies if for all functional dependencies
in F+ of the form
α → β
where α ⊆ R and β ⊆ R, at least one of the following
holds:
 α → β is trivial (i.e., β ⊆ α)
 α is a superkey for R
©Silberschatz, Korth and Sudarshan7.43Database System Concepts - 7th Edition
Boyce-Codd Normal Form (Cont.)
 Example schema that is not in BCNF:
in_dep (ID, name, salary, dept_name, building, budget)
because :
 dept_name→ building, budget holds on in_dep
 but dept_name is not a superkey
 When decompose in_dept into instructor and department
 instructor is in BCNF
 department is in BCNF
©Silberschatz, Korth and Sudarshan7.44Database System Concepts - 7th Edition
Decomposing a Schema into BCNF
 Let R be a schema that is not in BCNF.
 Let α →β be the FD that causes a violation of BCNF.
 We decompose R into:
• (α U β )
• ( R - ( β - α ) )
 In our example of in_dep,
 α = dept_name
 β = building, budget
and in_dep is replaced by
 (α U β ) = ( dept_name, building, budget )
 ( R - ( β - α ) ) = ( ID, name, dept_name, salary )
©Silberschatz, Korth and Sudarshan7.45Database System Concepts - 7th Edition
Example
 R = (A, B, C)
F = {A → B, B → C)
 R1 = (A, B), R2 = (B, C)
 Lossless-join decomposition:
R1 ∩ R2 = {B} and B → BC
 Dependency preserving
 R1 = (A, B), R2 = (A, C)
 Lossless-join decomposition:
R1 ∩ R2 = {A} and A → AB
 Not dependency preserving
(cannot check B → C without computing R
1 R2)
©Silberschatz, Korth and Sudarshan7.46Database System Concepts - 7th Edition
BCNF and Dependency Preservation
 It is not always possible to achieve both BCNF and dependency
preservation
 Consider a schema:
dept_advisor(s_ID, i_ID, department_name)
 With function dependencies:
i_ID → dept_name
s_ID, dept_name → i_ID
 dept_advisor is not in BCNF
 i_ID is not a superkey.
 Any decomposition of dept_advisor (s_ID, i_ID) & (i_ID, dept_name)
will not include all the attributes in s_ID, dept_name → i_ID
 Thus, the decomposition is NOT be dependency preserving

©Silberschatz, Korth and Sudarshan7.47Database System Concepts - 7th Edition
Third Normal Form
 A relation schema R is in third normal form (3NF) if for all:
α → β in F+
at least one of the following holds:
 α → β is trivial (i.e., β ∈ α)
 α is a superkey for R
 Each attribute A in β – α is contained in a candidate key for R.
(NOTE: each attribute may be in a different candidate key)
 If a relation is in BCNF it is in 3NF (since in BCNF one of the first
two conditions above must hold).
 Third condition is a minimal relaxation of BCNF to ensure
dependency preservation (will see why later).
©Silberschatz, Korth and Sudarshan7.48Database System Concepts - 7th Edition
3NF Example
 Consider a schema:
dept_advisor(s_ID, i_ID, dept_name)
 With function dependencies:
i_ID → dept_name
s_ID, dept_name → i_ID
 Two candidate keys = {s_ID, dept_name}, {s_ID, i_ID }
 We have seen before that dept_advisor is not in BCNF
 R, however, is in 3NF
 s_ID, dept_name is a superkey
 i_ID → dept_name and i_ID is NOT a superkey, but:
{ dept_name} – {i_ID } = {dept_name } and
dept_name is contained in a candidate key
©Silberschatz, Korth and Sudarshan7.49Database System Concepts - 7th Edition
Redundancy in 3NF
 Consider the schema R below, which is in 3NF
 What is wrong with the table?
• R = (J, K, L )
• F = {JK → L, L → K }
• And an instance of a table:
• Repetition of information
• Need to use null values (e.g., to represent the relationship
l2, k2 where there is no corresponding value for J)

©Silberschatz, Korth and Sudarshan7.50Database System Concepts - 7th Edition
Comparison of BCNF and 3NF
 Advantages to 3NF over BCNF. It is always possible to
obtain a 3NF design without sacrificing losslessness or
dependency preservation.
 Disadvantages to 3NF.
 We may have to use null values to represent some of
the possible meaningful relationships among data
items.
 There is the problem of repetition of information.
©Silberschatz, Korth and Sudarshan7.51Database System Concepts - 7th Edition
Goals of Normalization
 Let R be a relation scheme with a set F of functional
dependencies.
 Decide whether a relation scheme R is in "good" form.
 In the case that a relation scheme R is not in "good"
form, need to decompose it into a set of relation scheme
{R1, R2, ..., Rn} such that:
 Each relation scheme is in good form
 The decomposition is a lossless decomposition
 Preferably, the decomposition should be dependency
preserving.
©Silberschatz, Korth and Sudarshan7.52Database System Concepts - 7th Edition
How good is BCNF?
 There are database schemas in BCNF that do not
seem to be sufficiently normalized
 Consider a relation
inst_info (ID, child_name, phone)
 where an instructor may have more than one
phone and can have multiple children
 Instance of inst_info

©Silberschatz, Korth and Sudarshan7.53Database System Concepts - 7th Edition
 There are no non-trivial functional dependencies
and therefore the relation is in BCNF
 Insertion anomalies – i.e., if we add a phone 981-
992-3443 to 99999, we need to add two tuples
(99999, David, 981-992-3443)
(99999, William, 981-992-3443)
How good is BCNF? (Cont.)
©Silberschatz, Korth and Sudarshan7.54Database System Concepts - 7th Edition
 It is better to decompose inst_info into:
 inst_child:
 inst_phone:
 This suggests the need for higher normal forms, such as
Fourth Normal Form (4NF), which we shall see later
Higher Normal Forms

©Silberschatz, Korth and Sudarshan7.55Database System Concepts - 7th Edition
Functional-Dependency Theory
©Silberschatz, Korth and Sudarshan7.56Database System Concepts - 7th Edition
Functional-Dependency Theory
Roadmap
 We now consider the formal theory that tells us
which functional dependencies are implied
logically by a given set of functional dependencies.
 We then develop algorithms to generate lossless
decompositions into BCNF and 3NF
 We then develop algorithms to test if a
decomposition is dependency-preserving
©Silberschatz, Korth and Sudarshan7.57Database System Concepts - 7th Edition
Closure of a Set of Functional
Dependencies
 Given a set F of functional dependencies, there
are certain other functional dependencies that
are logically implied by F.
 If A → B and B → C, then we can infer that
A → C, etc.
 The set of all functional dependencies logically
implied by F is the closure of F.
 We denote the closure of F by F+.
©Silberschatz, Korth and Sudarshan7.58Database System Concepts - 7th Edition
Closure of a Set of
Functional Dependencies
 We can compute F+, the closure of F, by repeatedly
applying Armstrong's Axioms:
 Reflexive rule: if β ⊆ α, then α → β
 Augmentation rule: if α → β, then γ α → γ β
 Transitivity rule: if α → β, and β → γ, then α → γ
 These rules are
 Sound -- generate only functional dependencies that
actually hold (correct)
 Complete -- generate all functional dependencies
that hold.
©Silberschatz, Korth and Sudarshan7.59Database System Concepts - 7th Edition
Example of F+
 R = (A, B, C, G, H, I)
F = { A → B
A → C
CG → H
CG → I
B → H}
 Some members of F+
 A → H
by transitivity from A → B and B → H
 AG → I
by augmenting A → C with G, to get AG → CG
and then transitivity with CG → I
 CG → HI
by augmenting CG → I to infer CG → CGI,
and augmenting of CG → H to infer CGI → HI,
and then transitivity
©Silberschatz, Korth and Sudarshan7.60Database System Concepts - 7th Edition
Closure of Functional
Dependencies (Cont.)
 Additional rules:
 Union rule: If α → β holds and α → γ holds,
then α → β γ holds.
 Decomposition rule: If α → β γ holds, then
α → β holds and α → γ holds.
 Pseudotransitivity rule:If α → β holds and
γ β → δ holds, then α γ → δ holds.
 The above rules can be inferred from Armstrong's
axioms.
©Silberschatz, Korth and Sudarshan7.61Database System Concepts - 7th Edition
Procedure for Computing F+
 To compute the closure of a set of functional dependencies F:
F + = F
repeat
for each functional dependency f in F+
apply reflexivity and augmentation rules on f
add the resulting functional dependencies to F +
for each pair of functional dependencies f1and f2 in F +
if f1 and f2 can be combined using transitivity
then add the resulting functional dependency to F +
until F + does not change any further
 NOTE: We shall see an alternative procedure for this task later
©Silberschatz, Korth and Sudarshan7.62Database System Concepts - 7th Edition
Closure of Attribute Sets
 Given a set of attributes α, define the closure of α under F
(denoted by α+) as the set of attributes that are functionally
determined by α under F
 Algorithm to compute α+, the closure of α under F
result := α;
while (changes to result) do
for each β → γ in F do
begin
if β ⊆ result then result := result ∪ γ
end
©Silberschatz, Korth and Sudarshan7.63Database System Concepts - 7th Edition
Example of Attribute Set Closure
 R = (A, B, C, G, H, I)
 F = {A → B
A → C
CG → H
CG → I
B → H}
 (AG)+
1. result = AG
2. result = ABCG (A → C and A → B)
3. result = ABCGH (CG → H and CG ⊆ AGBC)
4. result = ABCGHI (CG → I and CG ⊆ AGBCH)
 Is AG a candidate key?
1. Is AG a super key?
1. Does AG → R? == Is R ⊇ (AG)+
2. Is any subset of AG a superkey?
1. Does A → R? == Is R ⊇ (A)+
2. Does G → R? == Is R ⊇ (G)+
3. In general: check for each subset of size n-1
©Silberschatz, Korth and Sudarshan7.64Database System Concepts - 7th Edition
Uses of Attribute Closure
There are several uses of the attribute closure algorithm:
 Testing for superkey:
• To test if α is a superkey, we compute α+, and check if α+
contains all attributes of R.
 Testing functional dependencies
• To check if a functional dependency α → β holds (or, in
other words, is in F+), just check if β ⊆ α+.
• That is, we compute α+ by using attribute closure, and
then check if it contains β.
• Is a simple and cheap test, and very useful
 Computing closure of F
• For each γ ⊆ R, we find the closure γ+, and for each S ⊆
γ+, we output a functional dependency γ → S.
©Silberschatz, Korth and Sudarshan7.65Database System Concepts - 7th Edition
Canonical Cover
 Suppose that we have a set of functional dependencies F on a relation
schema. Whenever a user performs an update on the relation, the
database system must ensure that the update does not violate any
functional dependencies; that is, all the functional dependencies in F
are satisfied in the new database state.
 If an update violates any functional dependencies in the set F, the
system must roll back the update.
 We can reduce the effort spent in checking for violations by testing a
simplified set of functional dependencies that has the same closure as
the given set.
 This simplified set is termed the canonical cover
 To define canonical cover we must first define extraneous attributes.
 An attribute of a functional dependency in F is extraneous if we
can remove it without changing F +
©Silberschatz, Korth and Sudarshan7.66Database System Concepts - 7th Edition
Extraneous Attributes
 Removing an attribute from the left side of a functional dependency
could make it a stronger constraint.
 For example, if we have AB → C and remove B, we get the
possibly stronger result A → C. It may be stronger because A
→ C logically implies AB → C, but AB → C does not, on its
own, logically imply A → C
 But, depending on what our set F of functional dependencies
happens to be, we may be able to remove B from AB → C safely.
 For example, suppose that
 F = {AB → C, A → D, D → C}
 Then we can show that F logically implies A → C, making
extraneous in AB → C.
©Silberschatz, Korth and Sudarshan7.67Database System Concepts - 7th Edition
Extraneous Attributes (Cont.)
 Removing an attribute from the right side of a functional
dependency could make it a weaker constraint.
 For example, if we have AB → CD and remove C, we get the
possibly weaker result AB → D. It may be weaker because
using just AB → D, we can no longer infer AB → C.
 But, depending on what our set F of functional dependencies
happens to be, we may be able to remove C from AB → CD
safely.
 For example, suppose that
F = { AB → CD, A → C}.
 Then we can show that even after replacing AB → CD by AB
→ D, we can still infer AB → C (from A C) and thus AB →
CD.
©Silberschatz, Korth and Sudarshan7.68Database System Concepts - 7th Edition
Extraneous Attributes
 An attribute of a functional dependency in F is extraneous if we
can remove it without changing F +
 Consider a set F of functional dependencies and the functional
dependency α → β in F.
 Remove from the left side: Attribute A is extraneous in α if
 A ∈ α and
F logically implies (F – {α → β}) ∪ {(α – A) → β}.
 Remove from the right side: Attribute A is extraneous in β if
A ∈ β and
The set of functional dependencies
(F – {α → β}) ∪ {α →(β – A)} logically implies F.
 Note: implication in the opposite direction is trivial in each of the
cases above, since a "stronger" functional dependency always
implies a weaker one
©Silberschatz, Korth and Sudarshan7.69Database System Concepts - 7th Edition
Testing if an Attribute is
Extraneous
 Let R be a relation schema and let F be a set of functional
dependencies that hold on R . Consider an attribute in the functional
dependency α → β.
 To test if attribute A ∈ β is extraneous in β
 Consider the set:
F' = (F – {α → β}) ∪ {α →(β – A)},
 check that α+ contains A; if it does, A is extraneous in β
 To test if attribute A ∈ α is extraneous in α
 Let γ = α – {A}. Check if γ → β can be inferred from F.
 Compute γ+ using the dependencies in F
 If γ+ includes all attributes of β then , A is extraneous in α
©Silberschatz, Korth and Sudarshan7.70Database System Concepts - 7th Edition
Examples of Extraneous
Attributes
 Let F = {AB → CD, A → E, E → C }
 To check if C is extraneous in AB → CD, we:
 Compute the attribute closure of AB under F = {AB → D,
A → E, E → C}
 The closure is ABCDE, which includes CD
 This implies that C is extraneous
©Silberschatz, Korth and Sudarshan7.71Database System Concepts - 7th Edition
Canonical Cover
 F logically implies all dependencies in Fc , and
 Fc logically implies all dependencies in F, and
 No functional dependency in Fc contains an extraneous
attribute, and
 Each left side of functional dependency in Fc is unique.
That is, there are no two dependencies in Fc
 α1 → β1 and α2 → β2 such that α1 = α2
A canonical cover for F is a set of dependencies Fc
such that
©Silberschatz, Korth and Sudarshan7.72Database System Concepts - 7th Edition
Canonical Cover
 To compute a canonical cover for F:
repeat
Use the union rule to replace any dependencies in F of the form
α1 → β1 and α1 → β2 with α1 → β1 β2
Find a functional dependency α → β in Fc with an extraneous
attribute either in α or in β
/* Note: test for extraneous attributes done using Fc, not F*/
If an extraneous attribute is found, delete it from α → β
until (Fc does not change)
 Note: Union rule may become applicable after some extraneous
attributes have been deleted, so it has to be re-applied
©Silberschatz, Korth and Sudarshan7.73Database System Concepts - 7th Edition
Example: Computing a
Canonical Cover
 R = (A, B, C)
F = {A → BC
B → C
A → B
AB → C}
 Combine A → BC and A → B into A → BC
 Set is now {A → BC, B → C, AB → C}
 A is extraneous in AB → C
 Check if the result of deleting A from AB → C is implied by the other
dependencies
 Yes: in fact, B → C is already present!
 Set is now {A → BC, B → C}
 C is extraneous in A → BC
 Check if A → C is logically implied by A → B and the other dependencies
 Yes: using transitivity on A → B and B → C.
– Can use attribute closure of A in more complex cases
 The canonical cover is: A → B
B → C
©Silberschatz, Korth and Sudarshan7.74Database System Concepts - 7th Edition
Example: Computing a
Canonical Cover (Cont..)
 R = (A, B, C)
F = {A → BC, B → AC, and C → AB}.
A → BC (Both B and C are extraneous, but we cannot delete both)
 If C deleted, then F′ = {A → B, B → AC, and C → AB}.
Now A and B are found to be extraneous in C → AB, this leads to two
choices
Fc = {A → B, B → C, C → A}
Fc = {A → B, B → AC, C → B}.
 If B deleted, then {A → C, B → AC, and C → AB}.
Now A and C are found to be extraneous in B → AC, this leads to two
choices
Fc = {A → C, C → B, and B → A}
Fc = {A → C, B → C, and C → AB}.
©Silberschatz, Korth and Sudarshan7.75Database System Concepts - 7th Edition
Dependency Preservation
 Let Fi be the set of dependencies in F + that include only attributes in Ri.
 A decomposition is dependency preserving, if
(F1 ∪ F2 ∪ … ∪ Fn )+ = F +
 Using the above definition, testing for dependency preservation take
exponential time.
 Not that if a decomposition is NOT dependency preserving then checking
updates for violation of functional dependencies may require computing
joins, which is expensive.
compute F+ ;
for each schema Ri in D do
begin
Fi : = the restriction of F+ to Ri ;
end
F′ := ∅
for each restriction Fi do
begin
F′ = F′ ∪ Fi
end
compute F′+ ;
if (F′+ = F+ ) then return (true)
else return (false);
©Silberschatz, Korth and Sudarshan7.77Database System Concepts - 7th Edition
Testing for Dependency
Preservation
 To check if a dependency α → β is preserved in a decomposition of R into
R1, R2, …, Rn , we apply the following test (with attribute closure done with
respect to F)
• result = α
repeat
for each Ri in the decomposition
t = (result ∩ Ri)+ ∩ Ri
result = result ∪ t
until (result does not change)
• If result contains all attributes in β, then the functional dependency α
→ β is preserved.
 We apply the test on all dependencies in F to check if a decomposition is
dependency preserving
 This procedure takes polynomial time, instead of the exponential time
required to compute F+ and (F1 ∪ F2 ∪ … ∪ Fn)+
©Silberschatz, Korth and Sudarshan7.78Database System Concepts - 7th Edition
Example
 R = (A, B, C )
F = {A → B
B → C}
Key = {A}
 R is not in BCNF
 Decomposition R1 = (A, B), R2 = (B, C)
 R1 and R2 in BCNF
 Lossless-join decomposition
 Dependency preserving
©Silberschatz, Korth and Sudarshan7.79Database System Concepts - 7th Edition
Algorithm for Decomposition
Using
Functional Dependencies
©Silberschatz, Korth and Sudarshan7.80Database System Concepts - 7th Edition
Testing for BCNF
 To check if a non-trivial dependency α →β causes a violation of BCNF
1. compute α+ (the attribute closure of α), and
2. verify that it includes all attributes of R, that is, it is a superkey of R.
 Simplified test: To check if a relation schema R is in BCNF, it suffices to
check only the dependencies in the given set F for violation of BCNF, rather
than checking all dependencies in F+.
 If none of the dependencies in F causes a violation of BCNF, then none
of the dependencies in F+ will cause a violation of BCNF either.
 However, simplified test using only F is incorrect when testing a relation in
a decomposition of R
 Consider R = (A, B, C, D, E), with F = { A → B, BC → D}
Decompose R into R1 = (A,B) and R2 = (A,C,D, E)
Neither of the dependencies in F contain only attributes from
(A,C,D,E) so we might be mislead into thinking R2 satisfies BCNF.
In fact, dependency AC → D in F+ shows R2 is not in BCNF.
©Silberschatz, Korth and Sudarshan7.81Database System Concepts - 7th Edition
Testing Decomposition for
BCNF
 Either test Ri for BCNF with respect to the restriction of F+ to Ri (that is,
all FDs in F+ that contain only attributes from Ri)
 Or use the original set of dependencies F that hold on R, but with the
following test:
for every set of attributes α ⊆ Ri, check that α+ (the attribute
closure of α) either includes no attribute of Ri- α, or includes all
attributes of Ri.
 If the condition is violated by some α → β in F, the dependency
α → (α+ - α) ∩ Ri
can be shown to hold on Ri, and Ri violates BCNF.
 We use above dependency to decompose Ri
To check if a relation Ri in a decomposition of R is in BCNF
©Silberschatz, Korth and Sudarshan7.82Database System Concepts - 7th Edition
BCNF Decomposition
Algorithm
result := {R };
done := false;
while (not done) do
if (there is a schema Ri in result that is not in BCNF)
then begin
let α → β be a nontrivial functional
dependency that holds on Ri such that α+ does not contain
Ri and α ∩ β = ∅;
result := (result – Ri ) ∪ (Ri – β) ∪ (α, β );
end
else done := true;
Note: each Ri is in BCNF, and decomposition is lossless-join.
©Silberschatz, Korth and Sudarshan7.83Database System Concepts - 7th Edition
Example of BCNF
Decomposition
 class (course_id, title, dept_name, credits, sec_id, semester, year, building,
room_number, capacity, time_slot_id)
 Functional dependencies:
 course_id→ title, dept_name, credits
 building, room_number→capacity
 course_id, sec_id, semester, year→building, room_number, time_slot_id
 A candidate key {course_id, sec_id, semester, year}.
 BCNF Decomposition:
 course_id→ title, dept_name, credits holds
but course_id is not a superkey.
 We replace class by:
course(course_id, title, dept_name, credits)
class-1 (course_id, sec_id, semester, year, building, room_number,
capacity, time_slot_id)
©Silberschatz, Korth and Sudarshan7.84Database System Concepts - 7th Edition
BCNF Decomposition (Cont.)
 course is in BCNF
 building, room_number→capacity holds on class-1
 but {building, room_number} is not a superkey for class-1.
 We replace class-1 by:
classroom (building, room_number, capacity)
section (course_id, sec_id, semester, year, building,
room_number, time_slot_id)
 classroom and section are in BCNF.
©Silberschatz, Korth and Sudarshan7.85Database System Concepts - 7th Edition
Third Normal Form
 There are some situations where
 BCNF is not dependency preserving, and
 efficient checking for FD violation on updates is important
 Solution: define a weaker normal form, called Third Normal
Form (3NF)
 Allows some redundancy (with resultant problems; we will
see examples later)
 But functional dependencies can be checked on individual
relations without computing a join.
 There is always a lossless-join, dependency-preserving
decomposition into 3NF.
©Silberschatz, Korth and Sudarshan7.86Database System Concepts - 7th Edition
3NF Example -- Relation
dept_advisor
 dept_advisor (s_ID, i_ID, dept_name)
F = {s_ID, dept_name → i_ID, i_ID → dept_name}
 Two candidate keys: (s_ID, dept_name) and (i_ID, s_ID)
 R is in 3NF
 s_ID, dept_name → i_ID
 i_ID → dept_name
dept_name is contained in a candidate key
©Silberschatz, Korth and Sudarshan7.87Database System Concepts - 7th Edition
Testing for 3NF
 Need to check only FDs in F, need not check all FDs in F+.
 Use attribute closure to check for each dependency α → β, if
α is a superkey.
 If α is not a superkey, we have to verify if each attribute in β is
contained in a candidate key of R
 This test is rather more expensive, since it involve finding
candidate keys
 Testing for 3NF has been shown to be NP-hard
 Interestingly, decomposition into third normal form
(described shortly) can be done in polynomial time
©Silberschatz, Korth and Sudarshan7.88Database System Concepts - 7th Edition
3NF Decomposition Algorithm
Let Fc be a canonical cover for F;
i := 0;
for each functional dependency α → β in Fc
i := i + 1;
Ri := α β
if none of the schemas Rj, 1 ≤ j ≤ i contains a candidate key for R
then
i := i + 1;
Ri := any candidate key for R;
/* Optionally, remove redundant relations */
repeat
if any schema Rj is contained in another schema Rk
then /* delete Rj */
Rj = Ri;
i=i-1;
return (R1, R2, ..., Ri)
©Silberschatz, Korth and Sudarshan7.89Database System Concepts - 7th Edition
3NF Example -- Relation
dept_advisor
 dept_advisor (s_ID, i_ID, dept_name)
F = {s_ID, dept_name → i_ID, i_ID → dept_name}
 Two candidate keys: (s_ID, dept_name) and (i_ID, s_ID)
 F1 = {s_ID, dept_name → i_ID}, F2 = { i_ID → dept_name}
 FC = F
 R1 = (s_ID, dept_name, i_ID )
 R2 = (i_ID → dept_name )
 R2 is subset of R1, also R1 contains the candidate key => R1 is in 3 NF
©Silberschatz, Korth and Sudarshan7.91Database System Concepts - 7th Edition
3NF Decomposition: An
Example Relation schema:
cust_banker_branch = (customer_id, employee_id, branch_name, type )
 The functional dependencies for this relation schema are:
 customer_id, employee_id → branch_name, type
 employee_id → branch_name
 customer_id, branch_name → employee_id
 We first compute a canonical cover
 branch_name is extraneous in the r.h.s. of the 1st dependency
 No other attribute is extraneous, so we get FC =
customer_id, employee_id → type
employee_id → branch_name
customer_id, branch_name → employee_id
©Silberschatz, Korth and Sudarshan7.92Database System Concepts - 7th Edition
3NF Decompsition Example
(Cont.)
 The for loop generates following 3NF schema:
(customer_id, employee_id, type )
(employee_id, branch_name)
(customer_id, branch_name, employee_id)
 Observe that (customer_id, employee_id, type ) contains a candidate
key of the original schema, so no further relation schema needs be
added
 At end of for loop, detect and delete schemas, such as (employee_id,
branch_name), which are subsets of other schemas
 result will not depend on the order in which FDs are considered
 The resultant simplified 3NF schema is:
(customer_id, employee_id, type)
(customer_id, branch_name, employee_id)
©Silberschatz, Korth and Sudarshan7.93Database System Concepts - 7th Edition
Comparison of BCNF and
3NF
 It is always possible to decompose a relation into a set of
relations that are in 3NF such that:
 The decomposition is lossless
 The dependencies are preserved
 It is always possible to decompose a relation into a set of
relations that are in BCNF such that:
 The decomposition is lossless
 It may not be possible to preserve dependencies.
©Silberschatz, Korth and Sudarshan7.94Database System Concepts - 7th Edition
Design Goals
 Goal for a relational database design is:
 BCNF.
 Lossless join.
 Dependency preservation.
 If we cannot achieve this, we accept one of
 Lack of dependency preservation
 Redundancy due to use of 3NF
 Interestingly, SQL does not provide a direct way of specifying functional
dependencies other than superkeys.
Can specify FDs using assertions, but they are expensive to test, (and
currently not supported by any of the widely used databases!)
 Even if we had a dependency preserving decomposition, using SQL we
would not be able to efficiently test a functional dependency whose left
hand side is not a key.
©Silberschatz, Korth and Sudarshan7.95Database System Concepts - 7th Edition
Multivalued Dependencies
©Silberschatz, Korth and Sudarshan7.96Database System Concepts - 7th Edition
Multivalued Dependencies
(MVDs)
 Suppose we record names of children, and phone numbers for
instructors:
 inst_child(ID, child_name)
 inst_phone(ID, phone_number)
 If we were to combine these schemas to get
 inst_info(ID, child_name, phone_number)
 Example data:
(99999, David, 512-555-1234)
(99999, David, 512-555-4321)
(99999, William, 512-555-1234)
(99999, William, 512-555-4321)
 This relation is in BCNF
 Why?
©Silberschatz, Korth and Sudarshan7.97Database System Concepts - 7th Edition
Multivalued Dependencies
 Let R be a relation schema and let α ⊆ R and β ⊆ R. The
multivalued dependency
α →→ β
holds on R if in any legal relation r(R), for all pairs for tuples t1
and t2 in r such that t1[α] = t2 [α], there exist tuples t3 and t4 in r
such that:
t1[α] = t2 [α] = t3 [α] = t4 [α]
t3[β] = t1 [β]
t3[R – β] = t2[R – β]
t4 [β] = t2[β]
t4[R – β] = t1[R – β]
©Silberschatz, Korth and Sudarshan7.98Database System Concepts - 7th Edition
MVD -- Tabular representation
 Tabular representation of α →→ β

©Silberschatz, Korth and Sudarshan7.99Database System Concepts - 7th Edition
MVD (Cont.)
 Let R be a relation schema with a set of attributes that are
partitioned into 3 nonempty subsets.
Y, Z, W
 We say that Y →→ Z (Y multidetermines Z )
if and only if for all possible relations r (R )
< y1, z1, w1 > ∈ r and < y1, z2, w2 > ∈ r
then
< y1, z1, w2 > ∈ r and < y1, z2, w1 > ∈ r
 Note that since the behavior of Z and W are identical it
follows that
Y →→ Z if Y →→ W
©Silberschatz, Korth and Sudarshan7.100Database System Concepts - 7th Edition
Example
 In our example:
ID →→ child_name
ID →→ phone_number
 The above formal definition is supposed to formalize the notion
that given a particular value of Y (ID) it has associated with it a
set of values of Z (child_name) and a set of values of W
(phone_number), and these two sets are in some sense
independent of each other.
 Note:
 If Y → Z then Y →→ Z
 Indeed we have (in above notation) Z1 = Z2
The claim follows.
©Silberschatz, Korth and Sudarshan7.101Database System Concepts - 7th Edition
Use of Multivalued
Dependencies
 We use multivalued dependencies in two ways:
1.To test relations to determine whether they are legal under
a given set of functional and multivalued dependencies
2. To specify constraints on the set of legal relations. We
shall concern ourselves only with relations that satisfy a
given set of functional and multivalued dependencies.
 If a relation r fails to satisfy a given multivalued dependency,
we can construct a relations r′ that does satisfy the
multivalued dependency by adding tuples to r.
©Silberschatz, Korth and Sudarshan7.102Database System Concepts - 7th Edition
Theory of MVDs
 From the definition of multivalued dependency, we can derive the following
rule:
 If α → β, then α →→ β
That is, every functional dependency is also a multivalued dependency
 The closure D+ of D is the set of all functional and multivalued
dependencies logically implied by D.
 We can compute D+ from D, using the formal definitions of functional
dependencies and multivalued dependencies.
 We can manage with such reasoning for very simple multivalued
dependencies, which seem to be most common in practice
 For complex dependencies, it is better to reason about sets of
dependencies using a system of inference rules (Appendix C).
©Silberschatz, Korth and Sudarshan7.103Database System Concepts - 7th Edition
Fourth Normal Form
 A relation schema R is in 4NF with respect to a set D of
functional and multivalued dependencies if for all multivalued
dependencies in D+ of the form α →→ β, where α ⊆ R and β
⊆ R, at least one of the following hold:
 α →→ β is trivial (i.e., β ⊆ α or α ∪ β = R)
 α is a superkey for schema R
 If a relation is in 4NF it is in BCNF
©Silberschatz, Korth and Sudarshan7.104Database System Concepts - 7th Edition
Restriction of Multivalued
Dependencies
 The restriction of D to Ri is the set Di consisting of
 All functional dependencies in D+ that include only
attributes of Ri
 All multivalued dependencies of the form
α →→ (β ∩ Ri)
where α ⊆ Ri and α →→ β is in D+
©Silberschatz, Korth and Sudarshan7.105Database System Concepts - 7th Edition
4NF Decomposition
Algorithmresult: = {R};
done := false;
compute D+;
Let Di denote the restriction of D+ to Ri
while (not done)
if (there is a schema Ri in result that is not in 4NF) then
begin
let α →→ β be a nontrivial multivalued dependency that
holds
on Ri such that α → Ri is not in Di, and α∩β=φ;
result := (result - Ri) ∪ (Ri - β) ∪ (α, β);
end
else done:= true;
Note: each Ri is in 4NF, and decomposition is lossless-join
©Silberschatz, Korth and Sudarshan7.106Database System Concepts - 7th Edition
Example
 R =(A, B, C, G, H, I)
F ={ A →→ B
B →→ HI
CG →→ H }
 R is not in 4NF since A →→ B and A is not a superkey for R
 Decomposition
a) R1 = (A, B) (R1 is in 4NF)
b) R2 = (A, C, G, H, I) (R2 is not in 4NF, decompose into R3
and R4)
c) R3 = (C, G, H) (R3 is in 4NF)
d) R4 = (A, C, G, I) (R4 is not in 4NF, decompose into R5 and R6)
 A →→ B and B →→ HI  A →→ HI, (MVD transitivity), and
 and hence A →→ I (MVD restriction to R4)
e) R5 = (A, I) (R5 is in 4NF)
f)R6 = (A, C, G) (R6 is in 4NF)
©Silberschatz, Korth and Sudarshan7.107Database System Concepts - 7th Edition
Additional issues
©Silberschatz, Korth and Sudarshan7.108Database System Concepts - 7th Edition
Further Normal Forms
 Join dependencies generalize multivalued dependencies
 lead to project-join normal form (PJNF) (also called fifth normal
form)
 A class of even more general constraints, leads to a normal form called
domain-key normal form.
 Problem with these generalized constraints: are hard to reason with, and
no set of sound and complete set of inference rules exists.
 Hence rarely used
©Silberschatz, Korth and Sudarshan7.109Database System Concepts - 7th Edition
Overall Database Design Process
 R could have been generated when converting E-R diagram to a set
of tables.
 R could have been a single relation containing all attributes that are of
interest (called universal relation).
 Normalization breaks R into smaller relations.
 R could have been the result of some ad hoc design of relations,
which we then test/convert to normal form.
We have assumed schema R is given
©Silberschatz, Korth and Sudarshan7.110Database System Concepts - 7th Edition
ER Model and Normalization
 When an E-R diagram is carefully designed, identifying all entities
correctly, the tables generated from the E-R diagram should not need
further normalization.
 However, in a real (imperfect) design, there can be functional
dependencies from non-key attributes of an entity to other attributes of the
entity
 Example: an employee entity with
 attributes
department_name and building,
 functional dependency
department_name→ building
 Good design would have made department an entity
 Functional dependencies from non-key attributes of a relationship set
possible, but rare --- most relationships are binary
©Silberschatz, Korth and Sudarshan7.111Database System Concepts - 7th Edition
Denormalization for Performance
 May want to use non-normalized schema for performance
 For example, displaying prereqs along with course_id, and title requires
join of course with prereq
 Alternative 1: Use denormalized relation containing attributes of course
as well as prereq with all above attributes
 faster lookup
 extra space and extra execution time for updates
 extra coding work for programmer and possibility of error in extra
code
 Alternative 2: use a materialized view defined a course prereq
 Benefits and drawbacks same as above, except no extra coding work
for programmer and avoids possible errors
©Silberschatz, Korth and Sudarshan7.112Database System Concepts - 7th Edition
Other Design Issues
 Some aspects of database design are not caught by normalization
 Examples of bad database design, to be avoided:
Instead of earnings (company_id, year, amount ), use
 earnings_2004, earnings_2005, earnings_2006, etc., all on the
schema (company_id, earnings).
 Above are in BCNF, but make querying across years difficult and
needs new table each year
 company_year (company_id, earnings_2004, earnings_2005,
earnings_2006)
 Also in BCNF, but also makes querying across years difficult and
requires new attribute each year.
 Is an example of a crosstab, where values for one attribute
become column names
 Used in spreadsheets, and in data analysis tools
©Silberschatz, Korth and Sudarshan7.113Database System Concepts - 7th Edition
Modeling Temporal Data
 Temporal data have an association time interval during which the data are
valid.
 A snapshot is the value of the data at a particular point in time
 Several proposals to extend ER model by adding valid time to
 attributes, e.g., address of an instructor at different points in time
 entities, e.g., time duration when a student entity exists
 relationships, e.g., time during which an instructor was associated with
a student as an advisor.
 But no accepted standard
 Adding a temporal component results in functional dependencies like
ID → street, city
not holding, because the address varies over time
 A temporal functional dependency X → Y holds on schema R if the
functional dependency X  Y holds on all snapshots for all legal instances
r (R).
©Silberschatz, Korth and Sudarshan7.114Database System Concepts - 7th Edition
Modeling Temporal Data (Cont.)
 In practice, database designers may add start and end time attributes to
relations
 E.g., course(course_id, course_title) is replaced by
course(course_id, course_title, start, end)
 Constraint: no two tuples can have overlapping valid times
 Hard to enforce efficiently
 Foreign key references may be to current version of data, or to data at a
point in time
 E.g., student transcript should refer to course information at the time
the course was taken
©Silberschatz, Korth and Sudarshan7.115Database System Concepts - 7th Edition
End of Chapter 7
©Silberschatz, Korth and Sudarshan7.116Database System Concepts - 7th Edition
Proof of Correctness of 3NF
Decomposition Algorithm
©Silberschatz, Korth and Sudarshan7.117Database System Concepts - 7th Edition
Correctness of 3NF Decomposition Algorithm
 3NF decomposition algorithm is dependency preserving (since there is a
relation for every FD in Fc)
 Decomposition is lossless
 A candidate key (C ) is in one of the relations Ri in decomposition
 Closure of candidate key under Fc must contain all attributes in R.
 Follow the steps of attribute closure algorithm to show there is only
one tuple in the join result for each tuple in R
i
©Silberschatz, Korth and Sudarshan7.118Database System Concepts - 7th Edition
Correctness of 3NF Decomposition Algorithm (Cont.)
 Claim: if a relation Ri is in the decomposition generated by the above
algorithm, then Ri satisfies 3NF.
 Proof:
 Let Ri be generated from the dependency α → β
 Let γ → B be any non-trivial functional dependency on Ri. (We
need only consider FDs whose right-hand side is a single
attribute.)
 Now, B can be in either β or α but not in both. Consider each
case separately.
©Silberschatz, Korth and Sudarshan7.119Database System Concepts - 7th Edition
Correctness of 3NF Decomposition (Cont.)
 Case 1: If B in β:
 If γ is a superkey, the 2nd condition of 3NF is satisfied
 Otherwise α must contain some attribute not in γ
 Since γ → B is in F+ it must be derivable from Fc, by using attribute
closure on γ.
 Attribute closure not have used α →β. If it had been used, α must be
contained in the attribute closure of γ, which is not possible, since we
assumed γ is not a superkey.
 Now, using α→ (β- {B}) and γ → B, we can derive α →B
(since γ ⊆ α β, and B ∉ γ since γ → B is non-trivial)
 Then, B is extraneous in the right-hand side of α →β; which is not
possible since α →β is in Fc.
 Thus, if B is in β then γ must be a superkey, and the second
condition of 3NF must be satisfied.
©Silberschatz, Korth and Sudarshan7.120Database System Concepts - 7th Edition
Correctness of 3NF Decomposition (Cont.)
 Case 2: B is in α.
 Since α is a candidate key, the third alternative in the definition of
3NF is trivially satisfied.
 In fact, we cannot show that γ is a superkey.
 This shows exactly why the third alternative is present in the
definition of 3NF.
Q.E.D.
©Silberschatz, Korth and Sudarshan7.121Database System Concepts - 7th Edition
First Normal Form
 Domain is atomic if its elements are considered to be indivisible units
 Examples of non-atomic domains:
 Set of names, composite attributes
 Identification numbers like CS101 that can be broken up into parts
 A relational schema R is in first normal form if the domains of all attributes
of R are atomic
 Non-atomic values complicate storage and encourage redundant (repeated)
storage of data
 Example: Set of accounts stored with each customer, and set of
owners stored with each account
 We assume all relations are in first normal form (and revisit this in
Chapter 22: Object Based Databases)
©Silberschatz, Korth and Sudarshan7.122Database System Concepts - 7th Edition
First Normal Form (Cont.)
 Atomicity is actually a property of how the elements of the domain are
used.
 Example: Strings would normally be considered indivisible
 Suppose that students are given roll numbers which are strings of the
form CS0012 or EE1127
 If the first two characters are extracted to find the department, the
domain of roll numbers is not atomic.
 Doing so is a bad idea: leads to encoding of information in application
program rather than in the database.